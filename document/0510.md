###本日の予定
1. 課題の解説
1. C言語  
	* アドレとポインタ  
	* ポインタと配列
	* 構造体とは
	* malloc() と free()
	* 自己参照構造体について

____
###課題の解説
それぞれ自分たちが選んだ課題の解説をお願いします

____
###アドレスとは
- C言語ではメモリにアクセスする方法としてポインタというものがある
- 初学者にとってはC最大の鬼門といわれているが、よく考えればそこまで難しいものではない
- パソコンのメモリにはそれぞれ番地が設定されている
- 例えば、郵便局に手紙を出すときには必ず住所を入れるだろう
- それがわからなければ何所に届けていいかわからないからね

___
- 例えばint型で変数を用意し、それをprintfで表示したとする
- なぜ変数の値が表示されるのか？
- パソコンは魔法の道具ではないので、変数を用意した瞬間にどこかに保存しなければすぐに消えてしまう
- しかし、変数を保存したとしてもその場所を覚えていなければ意味がない
- つまり、変数にはどの場所に保存したかが、変数の値とともに保存されているのである

___

```
#include <stdio.h>

#include <stdio.h>

int main(){
	int a = 3,
		b = 3;
	printf("アドレス = %p , 値　= %d\n",&a,a );
	printf("アドレス = %p , 値　= %d\n",&b,b );

}
}
```
これを実行すると

>アドレス = 0022FF54 , 値　= 3  
アドレス = 0022FF50 , 値　= 3  


こういった結果が得られる

___
- `&varName`と表現することでその変数のアドレスを表現することができる
- そのときは`%p`でキャッチする
- 当たり前だが、変数ごとに保存されるアドレスは異なる
- 固有の住所がなければ手紙をとどけることは難しいからね
- ではポインタとはなにか？

____
###ポインタとは
- 先ほど`&varName`によってアドレスを表現した
- このようなアドレスを指すものをポインタという
- アドレスと何が違うのか迷うところだが、アドレスとは土地その物だと思ってもらいたい
- そこを指す住所がポインタである

```
ロ土地ロ <- 住所
 addr     pointer

```

___
####ポインタ型変数
- 変数を定義する時に`type* varName`と書くことでポインタの値を代入するポインタ型変数を定義することができる

```
#include <stdio.h>

int main(){
	int* a;
	int b = 3;
	
	a = &b;	//aにbのポインタを入れる
	printf("メモリアドレス = %p , 値　= %d\n",a,*a );
	printf("メモリアドレス = %p , 値　= %d\n",&b,b );
}
```

これを実行すると

>メモリアドレス = 0022FF50 , 値　= 3  
メモリアドレス = 0022FF50 , 値　= 3  


こういった結果が得られる

___
- `int* a`これでint型のポインタ変数を用意する
- これでaにはint型のポインタの値を代入することができる
- `a = &b`ここでaにはbのポインタの値を代入した
- 実行結果を見てみると同じ結果が得られる
- aはbのポインタ、つまりアドレスを入れているので同じアドレスが表示される
- また、ポインタ変数において`*varName`と表現することで、そのポインタが示す値を取得することができる
- 今回aはbのアドレスを示しているので、そこに格納されている3を取得した

___
- 例えば、住所1200001に住むbさんがいる  
` int b = 1200001;`
- そこに、aさんが居候としてやってきた  
- 当然aさんは居候なので同じ住所に住む(同じアドレス、変数値を持つ)  
`char* a;`  
`a = &b`
- つまり、aさんとbさんは同じアドレスと値を持つ

```
printf("メモリアドレス = %p , 値　= %d\n",a,*a );
printf("メモリアドレス = %p , 値　= %d\n",&b,b );
--------
メモリアドレス = 0022FF50 , 値　= 1200001
メモリアドレス = 0022FF50 , 値　= 1200001

```

___
- ポインタがなんとなく理解できたかな
- ではこうするとどうなる？

```
int main(){
	int* a;
	int b = 3;
	
	a = &b;	//aにbのポインタを入れる
	printf("メモリアドレス = %p , 値　= %d\n",a,*a );
	printf("メモリアドレス = %p , 値　= %d\n",&b,b );

	b = 5;
	printf("bの値を5に変更\n" );
	printf("メモリアドレス = %p , 値　= %d\n",a,*a );
	printf("メモリアドレス = %p , 値　= %d\n",&b,b );
}
```
結果はこうなる

___
>メモリアドレス = 0022FF50 , 値　= 3  
メモリアドレス = 0022FF50 , 値　= 3  
bの値を5に変更  
メモリアドレス = 0022FF50 , 値　= 5  
メモリアドレス = 0022FF50 , 値　= 5  



- bの値が変わるのは問題ない
- ではaの値まで変わるのはどうしてだろう

####答えは簡単だ
- aはbのアドレスを参照し、値を読み取っている
- つまり、`a = &b`でコピーするのはbのアドレスであって、値ではない
- `%d , *a`とやるたびにbの値を取得している
- これはポインタで何かするときに気をつけなければいけないポイントの一つである

____
###配列とポインタ
- 配列とポインタには密接なかかわりがある  
例えば

```
#include <stdio.h>

int main(){
	char firstName[] = "taro"; 
	char* familyName = "gakugei";
	printf("He is %s %s \n",firstName,familyName);
}
```

>`He is taro gakugei `

こういったように

___
また、配列と同じように

```
#include <stdio.h>

int main(){
	char* a = "gakugei";
	printf("%c%c%c%c \n",a[0],a[1],a[2],a[3]);
}
```
>`gaku`

と扱うこともできる

___
- また、ポインタはa[0]を示している

```
#include <stdio.h>

int main(){
	char* a = "gakugei";
	printf("%c %c \n",*a,*(a + 1));

	a++;
	printf("%c %c \n",*a,*(a + 1));
}
```
>g a  
a k  

つまり*a = a[0] であり \*(a + 1) = a[1] を示している  
また、aをインクリメントすることで、aの初期値をa[0]からa[1]に変更している

____
###構造体
- 例えば

```
人 ---名前
    |-身長
    |-体重
    |-年齢
```
といったように複数のデータを結び付けたいときには構造体というものをつかつ

- 構造体はこのように定義する

```
struct tagName{type varName;
				type varName;
}; 
```
その後`struct tagName varName`といったように呼び出す

___
例えば

```
#include <stdio.h>

struct parson{
	char* name;
	float height;
	float weight;
	int   age;
};

int main(){
	struct parson Jim = {"Jim Smith",170.2,63.2,22};

	printf("name is %s\nheight is %f\n",Jim.name,Jim.height );
	printf("weight is %f\nage is %d",Jim.weight,Jim.age);
}
```

>name is Jim Smith  
height is 170.199997  
weight is 63.200001  
age is 22   

___
- はじめに構造体について定義する
- その後`struct parson Jim`でsrtruct parson型の変数名Jimを定義した
- 構造体の中身にアクセスするときは`Jim.age`のように`.`を使用する

____
###mallocとfreeについて
- いままではメモリは勝手に確保されてきた
- しかし、これでは無駄が出る
- 例えば、配列では要素がわからない場合多めに用意することがあるが、実際にはそこまで要らない
- 
```
